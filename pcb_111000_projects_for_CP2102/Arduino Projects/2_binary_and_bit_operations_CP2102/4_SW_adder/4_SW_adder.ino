
/*
This program adds two binary numbers
The bits are summed in pairs.
Each summations may produce a carry
which must be added to the next two bits.

See
https://www.geeksforgeeks.org/digital-logic/binary-adder-with-logic-gates/

for an explanation.

Notice that some of the logic functions we have been looking at are key components
in an adder. We implement them here in software.  When implemented in hardware
they are called logic gates 

Bit_adder truth table

Inputs are A, B and Carry_in: Cin
Outputs are Sum and Carry_out: Cout

Logic adder truth table fot one pair of bits A and B
Cin is the carry generated by the previus pair if bits
Cout is the carry to be passed to the next summation.

A             0 0 0 0 1 1 1 1
B             0 0 1 1 0 0 1 1
Cin           0 1 0 1 0 1 0 1
A^B           0 0 1 1 1 1 0 0
(A^B)^Cin     0 1 1 0 1 0 0 1
Sum           0 1 1 0 1 0 0 1
Cout          0 0 0 1 0 1 1 1

if Cin is zero  Cout is A&B
if Cin is unity Cout is A|B
*/



#include "SW_adder_header.h"

int main (void) {
long Num_A, Num_B, Num_C;
char digits[8]; 

setup_328_HW;
for(int m = 0; m <= 7; m++)digits[m] = 0;
One_wire_comms_any_segment_clear_all();

if(reset_status != 2)String_to_PC_Basic
("\r\nEnter 2 numbers to be added together\r\n\
Then press sw1\r\n");
else String_to_PC_Basic("\r\n");

while(switch_1_down);

Num_A = Int_KBD_to_display(digits);
Num_B = Int_KBD_to_display(digits);

Num_C = Logic_Add (Num_A, Num_B);

digits[0] = Num_A;
digits[1] = Num_B;
digits[2] = Num_C;
One_wire_comms_3_bytes(digits);
Long_Hex_and_Int_to_PC_Basic (10, Num_C);

while(switch_1_up);
SW_reset;}



/*************************************************************************************/

long Logic_Add(long Num_1, long Num_2){
long Result_L = 0, Result_H = 0;
char Carry = 0;
char A, B;
long Result = 0;

for (int m = 0; m <=15; m++){
if (Low_bits(Num_1) & (1 << m)) A=1; else A=0;
if (Low_bits(Num_2) & (1 << m)) B=1; else B=0;

if (bit_sum (A, B, Carry))
Result_L |= (1 << m);
Carry = Carry_out(A, B, Carry);}

for (int m = 0; m <=15; m++){
if (High_bits(Num_1) & (1 << m)) A=1; else A=0;
if (High_bits(Num_2) & (1 << m)) B=1; else B=0;

if (bit_sum (A, B, Carry))
Result_H |= (1 << m);
Carry = Carry_out(A, B, Carry);}

return (((unsigned long)Result_H) << 16)  | (Result_L & 0xFFFF);}



/*************************************************************************************/
char bit_sum (char A, char B, char Carry_in)
{return (A^B)^Carry_in;}

char Carry_out (char A, char B, char Carry_in)
{if (Carry_in)return (A|B);
else return (A&B);}



/*************************************************************************************/
long High_bits(long Num)
{return Num >> 16;}


long Low_bits(long Num)
{return Num & 0xFFFF;}








/*****************************************************************************************************************************************/
