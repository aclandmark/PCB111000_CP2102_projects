
/*
This program adds two binary numbers
The bits are summed in pairs.
Each summations may produce a carry
which must be added to the next two bits.

See
https://www.geeksforgeeks.org/digital-logic/binary-adder-with-logic-gates/

for an explanation.

Notice that some of the logic functions we have been looking at are key components
in an adder. We implement them here in software.  When implemented in hardware
they are called logic gates 

Bit_adder truth table

Inputs are A, B and Carry_in: Cin
Outputs are Sum and Carry_out: Cout

Logic adder truth table fot one pair of bits A and B
Cin is the carry generated by the previus pair if bits
Cout is the carry to be passed to the next summation.

A             0 0 0 0 1 1 1 1
B             0 0 1 1 0 0 1 1
Cin           0 1 0 1 0 1 0 1
A^B           0 0 1 1 1 1 0 0
(A^B)^Cin     0 1 1 0 1 0 0 1
Sum           0 1 1 0 1 0 0 1
Cout          0 0 0 1 0 1 1 1

if Cin is zero  Cout is A&B
if Cin is unity Cout is A|B
*/



#include "SW_division_header.h"
#include "Local_subroutines.c"



//Type main rotine here
int main (void) {
long dividend, dividend_mem, divisor, result, modulo;

unsigned long mask = (unsigned long)0x80000000;
char digits[8],num_bits, num_bits_mem;
int q;

setup_328_HW;

if(reset_status != 2)String_to_PC_Basic
("\r\nEnter 2 numbers to be multiplied\r\n\
Then press sw1\r\n");
else String_to_PC_Basic("\r\n");

while(switch_1_down);

dividend = Int_KBD_to_display(digits);
String_to_PC_Basic(" / ");
divisor = Int_KBD_to_display(digits);
String_to_PC_Basic(" = ");
dividend_mem = dividend;
result = 0;
num_bits = 32;



/*********************Divide routine*************************/
while (!(dividend_mem & (mask))){dividend_mem = dividend_mem << 1; num_bits -=1;}
num_bits_mem = num_bits;

while ((dividend >> 1) >= divisor) {dividend =  (dividend >> 1); num_bits -= 1;}
for (int m = 0; m < num_bits; m++) dividend_mem = dividend_mem << 1;

for (int p = 0; p < (num_bits_mem - num_bits ); p++){
q = p;
  
dividend = Logic_subtract_Num1_Num_2(dividend, divisor);

result = (result << 1) | 1;   
dividend = dividend << 1; 
if (dividend_mem & mask)dividend |= 1;  

dividend_mem = dividend_mem << 1;

while (divisor > dividend) {result = (result << 1);  
p += 1; q += 1;
if (p == (num_bits_mem - num_bits))break; 
 dividend = dividend << 1; 
  if (dividend_mem & mask)dividend |= 1;
  dividend_mem = dividend_mem << 1;  }} 

if (q != (num_bits_mem - num_bits)){result = (result << 1) | 1;
modulo = dividend - divisor;}
else modulo = dividend;


Long_Hex_and_Int_to_PC_Basic (10, result);
String_to_PC_Basic(" % ");
Int_to_PC_Basic(modulo);
/************************************************************/


while(switch_1_up);
SW_reset;}



/***************************************************************/
void print_long_as_binary(long Num, char sym){
  unsigned long mask = (unsigned long)0x80000000;

for (int m = 0; m <= 31; m++){
  if (!(m%4)) Char_to_PC_Basic(' ');
  if ((unsigned long)Num & (mask)) Char_to_PC_Basic('1'); else Char_to_PC_Basic('0');
 mask = mask >> 1;
  } Char_to_PC_Basic(sym);newline_Basic();}







/*****************************************************************************************************************************************/
